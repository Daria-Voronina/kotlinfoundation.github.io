{"data":{"allMdx":{"nodes":[{"id":"ae8cea3f-54ad-592f-99d9-094cae189ed1","excerpt":"The Kotlin Foundation sponsored four projects for the Google Summer of Code 2023, and we are excited to announce the completion of a project to enhance the kotlinx-benchmark library! JetBrains, a Kotlin Foundation member, provided mentoring support for this project. The contributor to this project was Henok Woldesenbet, an aspiring software engineer and the mentor was Abduqodiri Qurbonzoda, a software developer working on Kotlin libraries at JetBrains. The project aimed to improve the kotlinx-benchmark library API and user experience.\n\nIntroduction\n\nThe kotlinx-benchmark library is an invaluable open-source tool that facilitates the benchmarking of multiplatform code written in Kotlin. Despite its essential function, its user experience had some gaps, confusing users and lacking features that developers have come to expect from benchmarking libraries.\n\nGoals\n\nThe primary goals for the project were:\n\nInfuse the library with clear and concise documentation, supplemented with practical usage examples. The absence of comprehensive documentation previously made using kotlinx-benchmark challenging for many, especially newcomers. Address user concerns and lint the library API, making it more intuitive and user friendly. Refine the library's internals, including by enhancing integration tests, improving error feedback through refined validations and task descriptions, and streamlining the profiler's execution process. Elevate the overall user experience, transforming the kotlinx-benchmark from a budding tool into a robust library that the Kotlin community can rely on.\nAchievements\n\nHere are the primary achievements made in the Google Summer of Code project:\n\nDocumentation for increased accessibility: Detailed documentation was added, ensuring that anyone, from novices to experts, could dive into, experiment with, and harness the power of the library. Improved error messages: A library's UX is significantly influenced by the quality of its error feedback. Error messages were revamped, ensuring they are not only accurate but also instructive, guiding users towards solutions. Refined integration tests: Comprehensive integration tests were added to ensure stability across a variety of use cases. Tech stack modernization: The library was migrated to the latest versions of Gradle and JMH, and transitioned from Groovy DSL to the latest version of Kotlin DSL to optimize the build scripts. Streamlined profiler usage: In response to feedback from our users, the process of running profilers was simplified, facilitating a smoother user experience.\nNext Steps\n\nTo further enhance kotlinx-benchmark, we are planning to:\n\nSupport the Android target and integrate the androidx.benchmark framework into kotlinx-benchmark. Implement an IntelliJ IDEA plugin to support running benchmarks with a click of a run button, the same way as running unit tests.\n\nIf you'd like to help continue improving kotlinx-benchmark, check out the open issues for ideas on where to jump in.\n\nThank you Henok and Abduqodiri for making kotlinx-benchmark even better for Kotlin developers!","fields":{"slug":"/news/gsoc-2023-kotlinx-benchmark/"},"frontmatter":{"date":"January 09, 2024","title":"Google Summer of Code 2023 – Enhancing kotlinx-benchmark's API and User Experience","spoilerSize":null}},{"id":"49ba8d96-e4cf-5117-b5f0-b88f14120e7b","excerpt":"The Kotlin Foundation sponsored four projects for Google Summer of Code 2023, and we are excited to announce the completion of the Parallel Stacks for Kotlin Coroutines in the Debugger project, for which Google, a Kotlin Foundation member, provided mentoring support. Today we'd like to share the details of the project with you. The primary contributor to this project was Raehat Singh Nanda, a computer science undergraduate, mentored by Nikita Nazarov, Kotlin Compiler Engineer on the Android team at Google. The project aimed to provide a visual way to debug applications using multiple coroutines.\n\nProject Goals\n\nWhile coroutines streamline asynchronous coding, debugging multiple coroutines can pose challenges, especially in large-scale applications. IntelliJ IDEA's Coroutines tab provides the ability to visualize coroutines, but it doesn't provide functionality to understand the connections between different but related coroutines.\n\nThe new Coroutine Stacks IntelliJ IDEA plugin provides a graphical depiction of numerous coroutines in specific application states. This innovation draws inspiration from the Parallel Stacks feature found in established IDEs such as JetBrains Rider, JetBrains CLion, and Microsoft Visual Studio.\n\nUpon initiating the IntelliJ IDEA debugger and encountering a breakpoint, an application enters a suspended state. Then, the Coroutine Stacks panel displays a parallel stack view that facilitates in-depth analysis for debugging purposes.\n\nCoroutine Stacks\n\nConsider the following code sample with multiple coroutines:\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch {\n        withContext(Dispatchers.Default) {\n            println()\n            delay(1000)\n        }\n    }\n    \n    \n    launch {\n        withContext(Dispatchers.Default) {\n            println()\n            delay(1000)\n        }\n    }\n}\n\n\nLet’s add a breakpoint on the following line:\n\nTo open the Coroutine Stacks panel, click in the bottom right-hand corner of your main IDE panel:\n\nAfter the debugger stops at the breakpoint and opens the panel, you will see something like this:\n\nThe Coroutine Stacks panel shows a graphical representation of different stack traces from different coroutines.\n\nFrom the image above, it is clear that there are two coroutines in the application. Their stack traces share a number of frames up until resumeWith. After that, the control flow of these coroutines diverges. The stack trace with the blue border refers to the coroutine that contains the current breakpoint. The frames highlighted in yellow come from libraries. You can hide library frames by clicking the filter button:\n\nNow you can see that the stack traces of the two running coroutines only have library frames in common.\n\nIn the example, all coroutines are running on the same dispatcher, but you can switch the dispatcher by using the dropdown menu at the top of the panel:\n\nUse the minus button to zoom out. You can return to normal size by clicking the plus or the 1:1 button:\n\nYou can also add coroutine creation frames by clicking this button:\n\nThe creation frames are highlighted in blue. For more complex examples, the coroutine trace graph can change dramatically after the creation frames are added.\n\nClick the photo button to capture a coroutine dump:\n\nYou can click on the frames to navigate to the corresponding source code position:\n\nInstallation\n\nGo to Settings / Preferences | Plugins in IntelliJ IDEA.\n\nSwitch to Marketplace and search for Coroutine Stacks:\n\nSelect the plugin and click Install.\n\nAfter the installation has been completed, restart the IDE.\n\nFeel Free to Contribute!\n\nThis is just the beginning! With new ideas and features, we can improve the tool to cover more use cases. If you’ve found a bug, don’t like how a feature works, or have other feedback, feel free to open an issue in our official GitHub repository: https://github.com/nikita-nazarov/coroutine-stacks\n\nThank you to Raehat and Nikita for building an awesome new tool to help developers be more productive!","fields":{"slug":"/news/gsoc-2023-parallel-stacks/"},"frontmatter":{"date":"January 08, 2024","title":"Google Summer of Code 2023 – Parallel Stacks for Kotlin Coroutines in the Debugger","spoilerSize":null}}]}}}