{"data":{"allMdx":{"nodes":[{"id":"49ba8d96-e4cf-5117-b5f0-b88f14120e7b","excerpt":"The Kotlin Foundation sponsored four projects for Google Summer of Code 2023, and we are excited to announce the completion of the Parallel Stacks for Kotlin Coroutines in the Debugger project, for which Google, a Kotlin Foundation member, provided mentoring support. Today we'd like to share the details of the project with you. The primary contributor to this project was Raehat Singh Nanda, a computer science undergraduate, mentored by Nikita Nazarov, Kotlin Compiler Engineer on the Android team at Google. The project aimed to provide a visual way to debug applications using multiple coroutines.\n\nProject Goals\n\nWhile coroutines streamline asynchronous coding, debugging multiple coroutines can pose challenges, especially in large-scale applications. IntelliJ IDEA's Coroutines tab provides the ability to visualize coroutines, but it doesn't provide functionality to understand the connections between different but related coroutines.\n\nThe new Coroutine Stacks IntelliJ IDEA plugin provides a graphical depiction of numerous coroutines in specific application states. This innovation draws inspiration from the Parallel Stacks feature found in established IDEs such as JetBrains Rider, JetBrains CLion, and Microsoft Visual Studio.\n\nUpon initiating the IntelliJ IDEA debugger and encountering a breakpoint, an application enters a suspended state. Then, the Coroutine Stacks panel displays a parallel stack view that facilitates in-depth analysis for debugging purposes.\n\nCoroutine Stacks\n\nConsider the following code sample with multiple coroutines:\n\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch {\n        withContext(Dispatchers.Default) {\n            println()\n            delay(1000)\n        }\n    }\n    \n    \n    launch {\n        withContext(Dispatchers.Default) {\n            println()\n            delay(1000)\n        }\n    }\n}\n\n\nLet’s add a breakpoint on the following line:\n\nTo open the Coroutine Stacks panel, click in the bottom right-hand corner of your main IDE panel:\n\nAfter the debugger stops at the breakpoint and opens the panel, you will see something like this:\n\nThe Coroutine Stacks panel shows a graphical representation of different stack traces from different coroutines.\n\nFrom the image above, it is clear that there are two coroutines in the application. Their stack traces share a number of frames up until resumeWith. After that, the control flow of these coroutines diverges. The stack trace with the blue border refers to the coroutine that contains the current breakpoint. The frames highlighted in yellow come from libraries. You can hide library frames by clicking the filter button:\n\nNow you can see that the stack traces of the two running coroutines only have library frames in common.\n\nIn the example, all coroutines are running on the same dispatcher, but you can switch the dispatcher by using the dropdown menu at the top of the panel:\n\nUse the minus button to zoom out. You can return to normal size by clicking the plus or the 1:1 button:\n\nYou can also add coroutine creation frames by clicking this button:\n\nThe creation frames are highlighted in blue. For more complex examples, the coroutine trace graph can change dramatically after the creation frames are added.\n\nClick the photo button to capture a coroutine dump:\n\nYou can click on the frames to navigate to the corresponding source code position:\n\nInstallation\n\nGo to Settings / Preferences | Plugins in IntelliJ IDEA.\n\nSwitch to Marketplace and search for Coroutine Stacks:\n\nSelect the plugin and click Install.\n\nAfter the installation has been completed, restart the IDE.\n\nFeel Free to Contribute!\n\nThis is just the beginning! With new ideas and features, we can improve the tool to cover more use cases. If you’ve found a bug, don’t like how a feature works, or have other feedback, feel free to open an issue in our official GitHub repository: https://github.com/nikita-nazarov/coroutine-stacks\n\nThank you to Raehat and Nikita for building an awesome new tool to help developers be more productive!","fields":{"slug":"/news/gsoc-2023-parallel-stacks/"},"frontmatter":{"date":"January 08, 2024","title":"Google Summer of Code 2023 – Parallel Stacks for Kotlin Coroutines in the Debugger","spoilerSize":null}},{"id":"168c60a6-92cc-5044-a4b2-557d959cc333","excerpt":"The Kotlin Foundation sponsored 4 projects for the Google Summer of Code 2023 and we are excited to announce the completion of the KFlogger project, an experimental Kotlin Multiplatform version of Google's Flogger logging library! The contributor to this project was Giancarlo Buenaflor, a computer science undergraduate, and the mentor was Mark Mann, a Kotlin Multiplatform engineer at Google. Introduction\n\nFlogger, Google's default logging framework for JVM projects, opens up new opportunities for efficient cross-platform logging. The KFlogger project aims to enable the integration of Flogger into iOS and JVM, benefitting from the multiplatform capabilities of Kotlin.\n\nKFlogger incorporates the existing JVM Flogger codebase as a Java module, preserving its core functionality. The JVM implementation remains largely untouched and is directly actualized through the actual typealias mechanism. On the iOS side, KFlogger introduces a default logging backend based on OSLog.\n\nHere is a demo of this working on Android and iOS:\n\nGetting Started\n\nTo use KFlogger, add the following dependency to your commonMain sourceSet:\n\n// Find the latest version \n// on https://mvnrepository.com/artifact/com.giancarlobuenaflor/kflogger\nimplementation(\"com.buenaflor:kflogger:0.0.3\")\n\n\nThis will allow you to start simple logging. Add the KFluentLogger instance to your class and then you can start logging through your common code:\n\nimport com.giancarlobuenaflor.kflogger.KFluentLogger\n\nclass LoggingClass {\n    private val logger = KFluentLogger.forEnclosingClass()\n    \n    fun log() {\n        logger.atWarning().log(\"string: %s\", \"example\")\n        logger.atWarning().log(\"integer: %d:\", 1)\n        logger.atWarning().log(\"float: %f\", 1.0f)\n        logger.atWarning().log(\"%d%% %s\", 100, \"chance\")\n    }\n}\n\n\nThe source is in a GitHub repository and we'd love your feedback and contributions!\n\nThank you Giancarlo and Mark for helping make Kotlin Multiplatform even better!","fields":{"slug":"/news/gsoc-2023-kflogger/"},"frontmatter":{"date":"January 08, 2024","title":"Google Summer of Code 2023 - KFlogger (Kotlin Multiplatform Flogger)","spoilerSize":null}}]}}}